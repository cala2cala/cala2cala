# 网页性能指标

### LCP (Largest Contentful Paint) - 最大内容绘制

#### LCP测量的是从页面开始加载到可视区域（视口viewport）内最大内容元素完成渲染的时间点。这个"最大内容元素"通常是：

- 图片（包括img标签和CSS背景图）

- video元素

- 包含文本的块级元素（如段落、标题）

- SVG元素

- 带有背景图片的元素

#### LCP的重要性

- 用户体验指标：反映用户实际看到主要内容的时间

- SEO影响因素：Google明确将LCP作为搜索排名因素

- 业务指标相关：更好的LCP通常带来更高的转化率

#### LCP的评分标准

| LCP时间 | 评分等级 |
| :-----: | :------: |
| ≤2.5秒  |   良好   |
| 2.5-4秒 | 需要改进 |
|  >4秒   |   较差   |

### FCP (First Contentful Paint) - 首次内容绘制

衡量网页加载性能的核心Web指标。
用于记录浏览器首次渲染页面中任何可见内容（如文本、图像、非空白Canvas或SVG）的时间点。
它标志着用户感知页面开始加载的关键时刻，直接影响用户对“页面是否有效加载”的第一印象。

#### 为什么FCP重要？

- 用户体验
  FCP时间越短，用户越早感知到页面内容，减少跳出率。

- 搜索引擎优化（SEO）
  Google将FCP作为页面加载性能的评估指标，影响搜索排名。

#### FCP的测量标准

- 优秀（Good）：≤1.8秒

- 待改进（Needs Improvement）：1.8~3秒

- 差（Poor）：>3秒

#### 影响FCP的常见因素

- 服务器响应速度

慢的TTFB（Time to First Byte）延迟内容渲染。

- 渲染阻塞资源

未优化的CSS和JavaScript（尤其是头部同步加载的脚本）。

- 资源加载时间

大体积图片、字体文件或未压缩的静态资源。

- DOM复杂度

深层嵌套的HTML结构或过多的初始元素。

#### 如何优化FCP？

**1. 优化服务器和网络**
使用CDN加速资源分发。

启用HTTP/2或HTTP/3减少延迟。

优化TTFB：缓存静态资源，升级服务器配置。

**2. 消除渲染阻塞资源**
CSS优化：

内联关键CSS（Critical CSS），异步加载非关键CSS（通过preload）。

避免使用@import（会增加渲染阻塞）。

JavaScript优化：

使用async或defer延迟非关键脚本。

代码拆分（Code Splitting）按需加载。

**3. 预加载关键资源**

```javascript
<link rel="preload" href="main.css" as="style">
<link rel="preload" href="hero-image.jpg" as="image">
```

**4. 优化图片和字体**
压缩图片（WebP/AVIF格式）。

使用font-display: swap避免字体加载时的空白文本（FOIT）。

**5. 减少初始DOM复杂度**
避免复杂的HTML结构或过多的内联样式。

**6. 服务端渲染（SSR）或静态生成**
对于SPA（如React/Vue），使用SSR或预渲染技术加速首屏显示。

### FID (First Input Delay) - 首次输入延迟

衡量网页交互性能的重要核心Web指标（Core Web Vitals），用于**量化用户首次与页面交互（如点击按钮、链接或输入文本）到浏览器实际响应该交互之间的延迟时间**。它直接反映了用户对页面响应性的直观体验。

#### FID的测量标准

- 优秀（Good）：≤100毫秒

- 待改进（Needs Improvement）：100~300毫秒

- 差（Poor）：>300毫秒

#### FID的常见原因

- 主线程阻塞

长时间运行的JavaScript任务（如大型脚本解析、渲染阻塞代码）。

- 复杂的DOM渲染或样式计算。

- 资源加载竞争

浏览器正在加载、解析其他资源（如图片、CSS、JS），导致主线程繁忙。

- 第三方脚本

广告、分析工具等第三方代码可能占用主线程。

#### 如何优化FID？

- 减少主线程工作量

拆分长任务（Long Tasks）：将大型JavaScript任务拆分为小块，使用 setTimeout 或 requestIdleCallback。

- 延迟非关键JS：通过 async 或 defer 异步加载脚本。

- 优化代码执行时机

避免在DOM加载阶段（如 onload 事件）执行繁重操作。

- 移除不必要的第三方脚本

按需加载第三方资源，或使用 rel="preconnect" 提前建立连接。

- 使用Web Worker

将计算密集型任务移至Web Worker，释放主线程。

- 预加载关键资源

通过 \<link rel="preload"\> 提前加载必要资源。

### INP

是FID（首次输入延迟） 的进化版，更全面评估页面的整体交互性能，尤其在复杂 Web 应用（如单页应用 SPA）中更为关键。
INP 记录用户与页面交互（如点击、输入、滚动等）到屏幕实际更新（Next Paint）之间的延迟时间。
最终取所有交互延迟的最差值（如第 98 百分位数）作为页面的 INP 分数。

### CLS (Cumulative Layout Shift) - 累积布局偏移

衡量网页**视觉稳定性**的核心 Web 指标（Core Web Vitals）。
用于量化页面在加载过程中 意外布局偏移的程度。
它直接影响用户体验，尤其是当用户正要点击某个元素时，页面突然跳动，导致误操作（如误点广告或错误链接）。

#### 为什么 CLS 重要？

- 用户体验：意外的布局偏移会导致用户误操作，降低使用满意度。

- SEO 影响：Google 将 CLS 作为搜索排名因素之一。

- 业务影响：较高的 CLS 可能导致转化率下降（如用户误关页面或点错按钮）。

#### CLS 评分标准

| CLS 值   |              评级              |               用户体验影响 |
| :------- | :----------------------------: | -------------------------: |
| ≤ 0.1    |        ✅ Good（优秀）         |           几乎没有视觉偏移 |
| 0.1~0.25 | ⚠️ Needs Improvement（需改进） | 偶尔出现偏移，可能影响交互 |
| > 0.25   |         ❌ Poor（差）          |     频繁偏移，严重影响体验 |

#### 导致 CLS 的常见原因

- 未指定尺寸的图片或广告
- 动态插入内容（如广告、弹窗）
- 字体加载导致的布局偏移（FOIT/FOUT）
- 异步加载的组件（如评论、推荐模块）

### TTI (Time to Interactive) - 可交互时间

衡量网页 从加载到完全可交互 的关键性能指标，表示用户何时可以可靠地与页面进行交互（如点击按钮、输入表单等）。它直接影响用户体验，尤其是对于单页应用（SPA）和动态网页。

#### 为什么 TTI 重要？

- 用户体验：TTI 过长会让用户觉得页面卡顿或无响应，导致跳出率上升。

- 业务影响：较差的 TTI 可能降低转化率（如用户放弃提交表单或购物车）。

- SEO 影响：虽然 Google 未明确将 TTI 作为排名因素，但它影响 Core Web Vitals 相关指标（如 FID）

#### TTI 的计算方式

TTI 的计算基于以下条件：

- 首次内容绘制（FCP）已完成。

- 页面中所有可见元素已渲染（即主线程无长任务阻塞）。

- 用户输入（如点击、滚动）可在 50ms 内响应。

TTI = FCP + 主线程空闲时间（无长任务阻塞）

#### TTI 的评分标准

| TTI 时间（移动端） |             评 级              | 用户体验 |
| :----------------- | :----------------------------: | -------: |
| ≤ 3.8 秒           |        ✅ Good（优秀）         | 即时交互 |
| 3.9~7.3 秒         | ⚠️ Needs Improvement（需改进） | 轻微延迟 |
| > 7.3 秒           |         ❌ Poor（差）          | 明显卡顿 |

#### 导致 TTI 过高的常见原因

- JavaScript 执行时间过长
  未优化的 JS 代码（如未压缩、未拆包）。

同步加载的脚本阻塞主线程。

✅ 优化方式：

使用 async 或 defer 异步加载非关键 JS。

代码拆分（Code Splitting）按需加载。

- 主线程被长任务（Long Tasks）阻塞
  单次 JS 执行 > 50ms 的任务会延迟 TTI。

✅ 优化方式：

使用 setTimeout 或 requestIdleCallback 拆分长任务。

用 Web Workers 处理计算密集型任务。

- 过多的第三方脚本
  广告、分析工具、社交插件等可能占用主线程。

✅ 优化方式：

延迟加载非关键第三方脚本（如 load 事件后加载）。

使用 rel=preconnect 提前建立连接。

- 未优化的渲染流程
  复杂的 CSSOM 或 DOM 结构导致渲染延迟。

✅ 优化方式：

内联关键 CSS，减少渲染阻塞。

避免深层嵌套的 DOM 结构。

###

FPS 是衡量应用或页面动画流畅度的核心指标，表示每秒渲染的画面帧数。
高 FPS 意味着更流畅的视觉体验，低 FPS 则会导致卡顿、延迟，影响用户体验。

#### 影响 FPS 的关键因素

- JavaScript 执行
  长任务（Long Tasks）：主线程阻塞（如复杂计算、未优化的循环）导致帧延迟。

频繁 DOM 操作：触发重排（Reflow）和重绘（Repaint），增加渲染负担。

- 渲染性能
  复杂的 CSS：如阴影（box-shadow）、模糊（filter: blur()）会增加 GPU 负载。

图层管理不当：未利用 will-change 或 transform 优化合成层。

- 内存与资源加载
  内存泄漏：持续占用 GPU/CPU 资源，导致帧率逐渐下降。

未压缩的媒体资源：大图/视频解码消耗性能。

#### FPS 优化方案

- JavaScript 优化
  拆分长任务：使用 setTimeout 或 Web Workers 分片执行。

防抖/节流：限制高频事件（如 scroll、resize）的触发频率。

- 渲染优化
  GPU 加速：对动画元素使用 transform: translateZ(0) 或 will-change。

减少重绘：避免频繁修改 width/height，改用 transform。

离屏渲染：复杂动画可用 Canvas 或 WebGL 替代 DOM。

- 资源优化
  图片懒加载：减少首屏渲染压力。

视频降级：低带宽环境下切换为低分辨率。

### TTFB (Time to First Byte) - 首字节时间

指从客户端发起网络请求（如点击链接、输入URL）到接收到服务器返回的第一个字节数据之间的时间间隔。
它是衡量服务器响应速度的重要指标，反映了服务器处理请求和开始返回数据的效率。

#### TTFB的组成可分为以下三个阶段：

- 网络延迟：请求从客户端传输到服务器的时间（包括DNS查询、TCP握手、SSL协商等）。

- 服务器处理时间：服务器处理请求并生成响应的时间（如数据库查询、动态内容渲染）。

- 响应传输延迟：第一个字节从服务器传回客户端的时间（受网络带宽和拥塞影响）。

#### 健康指标参考

- 优秀：<100ms（静态资源通过CDN分发）。

- 可接受：100-500ms（动态内容）。

- 需优化：>500ms（可能存在服务器或网络问题）。

#### 优化建议

##### 服务器端优化：

- 升级服务器硬件（CPU、内存）或优化代码（如缓存高频查询）。

- 使 用CDN减少用户与服务器的物理距离。

- 启用HTTP/2或HTTP/3降低协议开销。

- 配置数据库索引或缓存（Redis/Memcached）加速动态内容生成。

##### 网络优化：

- 减少重定向（每次重定向增加TTFB）。

- 预连接（`<link rel="preconnect">`）提前建立TCP连接。

- 选择低延迟的DNS提供商或预解析DNS（`<link rel="dns-prefetch">`）
