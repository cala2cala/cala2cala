# 前端模块化

## 为什么需要模块化？
在早期，JavaScript 代码量少，直接写在 script 标签里即可。但随着前端应用变得无比复杂（SPA、交互复杂），代码量激增，没有模块化会导致以下问题：

1. 全局变量污染/命名冲突：每个脚本定义的变量都暴露在全局，很容易相互覆盖。

2. 依赖关系混乱：脚本的加载顺序必须手动管理，依赖关系不明确，难以维护。

3. 代码难以复用和维护：代码高度耦合，牵一发而动全身。

模块化就是为了解决这些问题而生的。

## 主流模块化规范

### ES6 模块化 (ES Modules - ESM)
这是 JavaScript 语言层面 实现的模块化标准，是未来的终极方案。

语法：

导出 (Export)：export / export default

导入 (Import)：import ... from ...

### CommonJS
CommonJS 模块已成为 Node.js 平台的默认模块系统。

#### 导出模块：module.exports

每个文件都是一个模块。模块内部有一个自由变量 module，它代表当前模块本身。module 对象有一个 exports 属性（即 module.exports），它就是你希望对外提供的内容。

#### 导入模块：require(id)
require 是一个全局函数，用于加载并导入另一个模块。


### ESM和CommonJS 区别
| 特性 | CommonJS | ES Modules (ESM) |
|:-------:|:--------:|:-------:|
| 加载方式	 | 同步（运行时加载）	   | 异步（编译时静态解析）|
| 值类型  | 值的拷贝（导出对象）    | 值的引用（动态绑定，只读）    |
| 树摇（Tree-shaking）  | 不支持（难以在打包时消除无用代码）    | 支持（利于打包优化，减小体积）    |


## webpack如何实现模块化