# 前端打包工具

现代前端工程化离不开打包工具。

它们将开发者编写的模块化代码及其依赖关系，转换、打包、优化为适合浏览器高效加载的静态资源。

## 解决的问题

1. 模块化：现代前端开发使用 ES Module (import/export) 或 CommonJS (require/module.exports) 来组织代码。浏览器对原生 ES Module 的支持仍有限制（如大量请求、旧浏览器不兼容），打包工具可以将这些模块打包合并成少数几个浏览器兼容的文件。

2. 代码转换与编译：让我们可以使用更新的语言特性和语法（如 TypeScript、ES6+、JSX、Sass/Less）。

- Babel：将 ES6+ 代码转换为向后兼容的 JS 语法。

- TS Compiler：将 TypeScript 转换为 JavaScript。

- Sass/Less 编译器：将 CSS 预处理器代码转换为纯 CSS。

3. 代码优化与压缩：移除开发环境的代码、注释、缩短变量名，进行 Tree Shaking（移除未使用的代码）和代码分割，显著减小文件体积，提升加载性能。
4. 开发体验：提供开发服务器（Dev Server）支持热模块替换（HMR），实现代码修改后浏览器无刷新更新，极大提高开发效率。
5. 资源处理：将非 JS 资源（如图片、字体、CSS）也视为模块，可以通过 import 引入，并处理优化（如压缩图片、生成 Data URL）。

## 打包工具发展

### 第一阶段：Grunt / Gulp (任务运行器时代)

开发者定义一系列任务，工具按顺序执行。

#### 致命缺陷：

依赖管理缺失：它只是机械地处理文件，不理解文件之间的依赖关系。你需要手动在 HTML 里按正确顺序引入一堆 `<script>` 标签。

资源浪费：合并所有文件会导致用户加载了大量根本用不到的代码（比如某个页面只用了 A 功能，却加载了包含 A-Z 所有功能的合并文件）。

### Webpack (模块打包器时代)

核心思想：一切皆模块（Everything is a module） 和 依赖图（Dependency Graph）。

#### 为什么它能“一统江湖”？

1. 解决了核心痛点：完美处理了模块依赖，开发者再也无需关心 \<script\> 标签的顺序。

2. 强大的 Loader 和 Plugin 系统：通过不同的 Loader，可以处理任何类型的资源（ts-loader, css-loader, file-loader），功能无限扩展。

3. 内置优化：代码分割（Code Splitting）、Tree Shaking（消除死代码）、作用域提升（Scope Hoisting） 等特性极大地优化了产物体积和运行性能。

4. 强大的生态：Create React App、Vue CLI 等官方脚手架早期都基于 Webpack，为其奠定了巨大的用户基础。

#### 带来的新问题：

配置复杂：webpack.config.js 变得非常庞大和难以理解，学习曲线陡峭。

性能瓶颈：项目越大，启动开发和打包构建的速度越慢。

### 后 Webpack 时代 (追求体验与性能)

Webpack 解决了模块化问题，但带来了速度和配置的负担。于是，新工具开始瞄准这些新痛点。

##### Vite / Snowpack：开发环境革命。

思路：利用浏览器原生支持 ESM 的特性，在开发环境不打包源代码。服务器按需编译和返回源文件，使得冷启动速度极快，热更新（HMR）效率极高。

##### esbuild：构建速度革命。

思路：用 Go 编写，多核并行，从语言层面追求极致的构建速度（比 Webpack 快 10-100 倍）。它通常不作为最终打包器，而是作为底层工具被 Vite 等使用。

##### Rolldown / Rspack / Turbopack：下一代打包器。

思路：用性能更高的语言（Rust）重写核心逻辑，在兼容 Webpack/Rollup 生态的同时，提供极致的速度体验。它们是用来“取代”或“增强” Webpack 的。
